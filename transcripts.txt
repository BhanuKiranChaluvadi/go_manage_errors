Course Overview
Hi everyone. My name is Corneile Britz, and welcome to my course, Managing Errors in Go. I'm the founder of Boxfish Consulting, and I've been working with and using Go to write all my software for over 10 years. The course is designed to give you a clear understanding of error management in Go, as well as some guidance on handling certain scenarios. Some of the highlights include using defer, panic, and recover to catch unexpected errors, creating your own custom errors, and detecting when they're used, handling errors when working with the HTTP stack, and effectively return and handle errors when working with multiple goroutines. By the end of the course, you'll know how to implement errors in Go and how to use them when the challenges present themselves. Before beginning the course, you should be familiar with Go to understand the examples and complete the exercises. I hope you will join me on this journey to learn how to manage errors in Go, at Pluralsight.

Error Management Overview
Overview
Welcome to the Managing Errors in Go course and how the language deals with exceptions. I'm Corneile Britz, founder of Boxfish Global. In this module, we will review the Go error object and how it is created, how it differs from unpopular languages, and some of the risks to take note of, options to create error objects, and examples from the standard Go libraries, and finally, the typical patterns that can result in Go programs crashing. Let's get started.

Error Object and Other Languages
Let's review the Go error object. Go does not define an error object as a typical structure, but rather as an interface exposing an error function to return a string. Errors can easily be constructed on the fly using Go's built‑in errors package, for example, calling the New function. Anything that implements a required interface can be used as an error. This allows us to create a wide range of errors from sentinel errors, custom errors to wrapping errors. We will cover these in detail shortly. With this in mind, it is clear how an error object in Go allows us to handle complex error scenarios effectively, for example, dealing with user input, unable‑to‑read file content, or perhaps struggling to communicate over the network. Let's explore how Go differs from other languages in the way it approaches error handling. Most current popular languages like Java, C#, Python, and JavaScript approach error management through the use of exception handling or even single result overloaded approach used in C. Let's look at an example. Exception handling is typically based on the following logic, a try block, which contains the necessary actions, one or more catch blocks responsible for capturing any possible exceptions, and a finally block that runs whether exceptions occurred or not. Our example contains numerous functions in the try block, which are all capable of throwing exceptions. The error block in our example either handles a specific scenario or a catch‑all option. The problem with this approach is that handling errors isn't always explicit and intentional, but can easily result in catch‑all logic, and the logic used to deal with errors differ from the code used for the rest of the program.

The Go Way
Let's now have a look at how Go approaches error handling. Go approaches error handling by returning it as explicit and separate values, typically, the last value returned from any function being called. It requires the code to deal with errors as they're returned using the same logic used elsewhere in the solution. Let's look at the Divide function. It accepts two integer input values and is expected to return a result or an error. If the divisor has a value of 0, the function returns a 0 result and an error, else, the result of the division will be returned with a nil error value. The main function cause a Divide function with two values receiving two returned values consisting of the result and an error. We can either deal with the error by checking if it is populated and respond to the error appropriately or we can take the risk and ignore the error entirely by replacing the variable with an underscore. In this example, we created the error on the fly, but that is not the only possible way. Let's look at different ways errors can be defined. In addition to the inline approach shown in the previous example, we can create an error on the fly using errors package and calling new, which will return a new error instance. We can also define an error as a reusable variable in our code called a sentinel error. And since the error interface is simple to implement, we can define custom error objects that contain much more detail in the example shown so far. There is an additional approach to handling errors in Go called wrapping errors, which we will cover in the upcoming modules.

Standard Library Examples
Let's now have a look at some examples from Go's standard library using the OS package to create a file by calling the Create function with a name and receiving the file object and an error as a response and using the ReadAll function from the IO package passing in a reader expecting a slice of bytes and an error as a response, and finally, writing data by calling the Write function passing in a slice of bytes and expecting the number of bytes written and an error as response. These are a few examples of Go's automatic approach to handling errors. But some scenarios can cause the application to crash, for example, working with objects of which the value is nil potentially results for ignoring an error, reading beyond the limits of an array, or even writing to a buffered channel which is full. And if we do nothing to prevent these errors, we can cause the entire system to crash ungracefully and dump a stack trace to the logs. There are ways to prevent ungraceful shutdown of a system, but we will cover these in later modules.

Summary
In this module, we review the Go error object and its design approach. We compared Go's approach to error handling to other popular languages. We looked at examples from the Go standard library, and we reviewed what can cause Go to crash. In the following modules, we will cover these errors, how to test them, and how to handle some typical scenarios. Next, we will look at how we can deal with errors using defer and put in some additional safety guardrails using panic and recover. See you there.

Error Types and Validation
Overview
Hi. Let's look at the different types of errors in Go and how we validate them in our solutions. I'm Corneile Britz, founder of Boxfish Global. In this module, we will review the error interface, as well as some examples of how it is implemented in the standard Go library. We will also review some additional standard library errors combined with the different ways they can be validated and the impact of each. And finally, we will review the focus of the entire course. Let's get started.

Error Types and Validation
The error type in Go is defined as an interface capable of describing itself as a string. This approach allows for the creation and use of numerous error implementations and variations. In simple terms, you can create any structure you want, and as long as it satisfies the interface, it is acceptable as an error. The most commonly‑used error implementation in Go, and definitely one you have used a lot, is the unexported errorString type. If you're not sure where you have used this, think about the following examples every time you called errors.New or perhaps fmt.Errorf. Now, let's review how we typically handle errors in Go. The first example of handling errors shows a snippet from the standard Go library for SQL database interaction. Please note that most of the codes surrounding the example has been removed for clarity. We can assume that we have a working database connection when we query the users table. This approach first completes the call to query the database and then explicitly validates a returned error value. This allows for the returned rows and errors to be used after the call and error check is complete due to the scope of the variables being outside the error handling block. However, if an error is returned, the error handling block would invoke a system exit in this case. The second example of handling errors shows the common challenge of parsing time. First, we define the data format we expect to be parsing. Second, we populate the variable with the time value we expect to be formatted. We then call the time.Parse function inside an if statement using a semicolon to separate instructions and then performing the actual conditional check for the if statement. If the condition is true, in this case, the error not being nil, the error handling block of the if statement will be evaluated. This approach completes the call and performs the error validation as a single inline statement. The risk of this call is the values returned from the function are bound to the scope of the if statement, meaning that any calls after the if statement would not have access to the variables. This approach is, however, very useful when a function populates a reference type and only returns a single error, for example, parsing JSON. Let's now review what the rest of the course will aim to achieve. The course is not only intended to focus on normal error constructs and how to validate those, although those are critical fundamentals to understand. The course will also focus on how to use different aspects of Go to manage errors and write anti‑fragile solutions by leveraging the power of Go. And finally, we will also cover some scenarios where error handling is not 100% clear, and we need to employ other techniques to trap and manage those errors.

Summary
In this module, we reviewed the following, the error interface and some common scenarios, the two approaches of validating errors and the risk of each related to the scope, and that the goal of the course is beyond straightforward error ending. As we just mentioned, our focuses part of the course is to build code that is not fragile. So in the next module, we will explore defer, panic, and recover functionality in Go. See you there.

Panic, Defer, and Recover
Overview
Hi. Let's explore the defer, panic, and recover functionality in Go. I'm Corneile Britz, founder of Boxfish Global. In this module, we will review, understand, and learn to use the defer statement to manage errors. We'll understand what the purpose of the Panic function is and how it differs from returning errors we've previously seen. And finally, how we can catch errors using the Recover function and stop the application from crashing entirely. Let's get started.

Panic, Defer, and Recover
Let's look at Go's defer statement, which is likely one of the best features in the language to control flow and keep code clean. The purpose of the defer statement is to push function calls onto a list as part of the surrounding function being called. Once the surrounding function returns, all the saved functions are executed. This approach is typically used to perform cleanup actions. Let's look at an example of copying a file. At first glance, the function looks correct, but there is a problem. If the os.Open call fails, the function will return without any issues, but if the os.Create call fails, the function returns as expected, but the file was accessed as part of os.Open would not be closed. As discussed in the previous module, other languages would typically add these cleanup functions in the finally block as part of exception handling. In a simple function like this, correction and overall code flow is straightforward to manage, but becomes increasingly complex in more significant functions. Let's look at the same example, but this time using the defer statement to perform the cleanup. By using a defer statement, we can achieve the following. The first is to clean up closing files or connections. The second is to deal with the clean up when it is created, making the code more readable. There are, however, some essential characteristics of a defer statement to note which are the defer functions arguments are evaluated when the defer statement is evaluated. After the surrounding function is returned, all the defer functions are executed in a last in, first out approach. And finally, the defer statement can read and assign named return values of the surrounding function, which is ideal if we need to modify values to provide better results. Another scenario where defer is helpful in addition to closing files or connections is to release mutexes. Let's now explore how this relates to managing errors in Go. Panic is a built‑in function and is typically used when the handling of an error does not allow for any clean way to recover. In this example, the panic function is used to perform the input validation for a division function, which will immediately abandon and return from the point of being called. Let's have a look at how the panic function behaves once called. The panic function is typically a call that deals with unexpected errors and results in execution of the current flow being stopped and starts panicking. When a specific function panics, it calls all the deferred functions saved for the surrounding function, and the panic will continue up the stack until all the functions are called potentially crashing the system. A typical example of when panic can occur is accessing an out‑of‑bounds array. It is clear how a panicking function is undesirable, so let's see how we can regain control of the panicking function in case it happens. Recover is also a built‑in function that is intended to regain control of a panicking Go routine. However, recover is only useful inside a deferred function as this ensures that it is called even if the code panics. When recovery is called, it returns an error result that can be checked. During regular operation, this value will be null and have no effect. If the Go return is panicking, this value would have the value provided by the panic function, after which the code would resume regular operation. This is an excellent opportunity to set the error values being returned.

Summary
In this module, we reviewed the following. The defer statements value is to manage errors and write clean and safe code. We reviewed how the panic function is used to stop the current flow of code and the recover function to regain control of the associated panic. Go convention is to only use panic internally in packages still protecting the overall package with recover functionality as this ensures the package behaves safely and predictably. In summary, the combination of defer, panic, and recover can be seen as an unusual approach to managing unexpected errors if you're used to exception management, but it is very efficient and powerful. Since we now know the basics of error management in Go, we will cover the testing of errors in the next module. See you there.

Testing Errors
Overview
Hi. Let's review how we can validate errors as part of automated testing. I'm Corneile Britz, founder of Boxfish Global. In this module, we will review how errors are tested using the built‑in testing framework and explore how we can cover numerous scenarios by leveraging table‑driven tests. Let's get started.

Testing Errors
We need a function to construct the tests for this module. Sample application calculates and returns the total based on two values provided, but will return an error if the following checks fail. Y must always be greater than 0, and x must always be greater than y. Let's have a look at the tests of this function. The first test will focus on the requirement that y must be greater than 0 by calling the function with values that would violate this requirement. As expected, the function will return a result and an error object which will need to be validated. First, we make sure that the total return is 0. Second, we ensure that the error object is populated, not null, and provide the expected error message. Test the second rule. We will construct test with values that result in x not being greater than y. This would, again, return a value and an error, and we would, again, validate that the result is 0, as well as the correct error is received. And then the final test will validate the total result. The total value is correct in this case, and the return error is null. This is a total of three test functions to test three scenarios. What if the amount of scenarios increase? Let's review the same test scenarios using table‑driven tests in Go. Table‑driven tests are ideal in this scenario where we need to cover multiple scenarios and return values from the same code reducing the repetition noted earlier. Table‑driven tests are constructed by instantiating a slice of structs containing the input and output members expected by our tests. Each scenario is then added by simply adding another instance to the slice. Once the list of test scenarios has been created, the tests are performed by simply iterating over the slice of scenarios, calling the function for each test scenario and passing in the expected values. For each call, the return value and errors are evaluated against the values provided by the test scenario ensuring that we will always test all the scenarios in future. This makes it easy to test multiple scenarios in our code, but we do have to add piece of information into our tests and output that to ensure that the team knows which test was executed or potentially failed.

Summary
In this module, we looked at how we test errors through automated testing and how we can reduce the efforts to add more tests to our code, especially to validate the errors. Table‑driven tests make it very easy to add scenarios to test without needing to construct brand‑new test functions. At this stage, we understand the basics of errors and how to add automated validation of the expected results. Let's look at our extend and customize errors in the next module. See you there.

Error Customization, Switching, and Assertion
Overview
Hi. Let's learn how we can leverage the error interface to create our own custom errors, detect which errors are raised, and respond appropriately. I'm Corneile Britz, founder of Boxfish Global. In this module, we will learn how to create and use custom error objects handling more complexity than a single string. We will also ensure that our code can attack specific error types in addition to the error interface and generic strings, and finally, how it can handle multiple errors through the use of switches and comparison. Let's get started.

Custom Error
Our first objective is to create our custom error to capture why a payment failed. The PaymentError struct contains the following four members, the reference number for the payment, the amount to be paid, the message why the error occurred, and the timestamp of when the error occurred. And we have also defined a new PaymentError method to create a new PaymentError instance auto‑populating the Timestamp. At this stage, this is a normal struct, so let's satisfy the error interface requirement. To satisfy the error interface, we add the Error function which outputs a nicely‑formatted string using all the information provided by the error, including the timestamp. We now have a custom error object which we can use throughout our solution. Let's now explore how we can populate and return this custom error. We need a function that can evaluate information and provide the required errors for our examples to make sense. The function first checks if the reference number is populated, returning the defined sentinel error if the check fails. The function then checks the amount provided, returning a custom payment error if it is greater than 100. For clarity, we will only focus on the error scenarios returned by the process payment function and will use these throughout the rest of the module. Let's now explore how we can detect and consume these different error objects, including our custom error.

Detecting Errors
Let's perform error detection through use of assertion. When we call the ProcessPayment function, it returns a single err. In the if statement, we use type assertion to test and assign the err object and the ok variable. If in this scenario the ok value is true, it confirms the error is indeed a PaymentError object. Alternatively, it would be treated as a generic error. By running the sample code, the output confirms the error type and the formatted Error object output. Let's perform error detection through the use of the built‑in errors.As function. In this example, the errors are being tested by passing in the received err object, as well as a reference to a pmtErr object. The errors.As function responds with a Boolean value of true signifying if the error is indeed a PaymentError object. If it is, the pmtErr object that we've passed in would also be populated. Alternatively, it would, again, be treated as a generic error. Using the errors.As function is preferable at times compared to the assertion approach due to the checking for a match by unwrapping the first error and matching it with a target error at each step. By running the sample code, the output, again, confirms the error type and the formatted Error object output similar to what we saw in the previous example. Let's now try to detect multiple errors through the use of switch statements. In order to handle multiple errors, we could easily look at using multiple if statements, but that would become unwieldy very fast. Go's built‑in switch statement has the ability to perform type detection on errors, as well as assign the correct type to a variable, in this case, as variable e. This variable can then be used as if you are working with original type. The default option would treat the error as a generic type. The output, again, confirms the error type and the formatted Error object output. Finally, let's detect errors through direct comparison. To test for sentinel errors, we can, again, rely on the if or the switch statement and directly compare the types. Since we know that our ProcessPayment function returns the InvalidPaymentType error, we can compare the err object against the same sentinel error. If it matches, we know it is a sentinel error. The default option will, again, treat the err object as a generic type. You will, again, see the output by running the code confirming the sentinel error is being returned with a formatted output. Please note that this does not perform a text comparison of the message, so it is important that you return and compare the same sentinel error.

Summary
In this module, we created and used our custom error type in a function. We also looked at the different options for detecting errors returned from the function and how we can leverage the switch statement to deal with multiple errors. Using custom errors, you can capture a lot more detail as part of the error response that would otherwise be lost as a single string, but due to it being a structure with private and public members, you can easily provide information in a structured format, perfect for logging. It would also be easy to provide the information as metrics to a solution like Prometheus. We now understand the basics of errors, creating our custom error objects, and detecting when they are returned. Let's start focusing on some scenarios you may encounter when writing solutions, starting with handling HTTP errors. See you there.

Handling HTTP Errors & Statuses
Overview
Hi. Let's look at handling some of the common error scenarios you may encounter when working with HTTP calls. I'm Corneile Britz, founder of Boxfish Global. In this module, we will look at the things to consider when handling inbound HTTP requests, and when we encounter any problems, how to respond appropriately to make it easy for clients to consume your service. We will then also consider some additional error handling approaches and hosting the HTTP server, finally, review the errors to look out for when making HTTP requests. Let's get started.

Inbound Calls
Let's now look at inbound HTTP calls. Let's start with the query values being passed through an API as part of HTTP request, such as a filter or a sort request. In our example, we expect the query value of name to be provided. Query values are provided as a map with a string as the key and a slice of strings as the value. Even if you pass a single value to the query, it will still be a slice, and you need to ensure that it's populated. If this check fails, you can respond with the appropriate HTTP status error, for example, a Bad Request error, which you can see as part of the response, and when finally reading the value, it needs to be done in the same way you would normally read values for a slice by using an index. The value can then be consumed as normal. If you fail to perform these checks, you may encounter an out‑of‑bounds error as we noted in previous modules. For the next example, we will use the Person struct. It is important to note the JSON tags being used to specify serialization. In this example, our query handler expects a person payload to be sent as part of the post requests body, but since the body is passed in as bytes, we need to decode the body into a Person variable. Of course, this function will return an err if the body is not in a JSON format. If this returns an error, you can, again, respond with appropriate Bad Request error as a response to the caller. If this succeeds, you can use the Person information as a normal object and respond to the caller. Please note that this will not validate if it is a valid person payload, so you would need to validate the content in your own solution. But let's look at our HTTP errors all populated and sent back to the caller. The first handler shows a scenario where the appropriate error text is written to the response, and then the header is populated in order to return the correct status code. Both these values must be set to correctly send error responses. It may confuse a caller if a status code 200 is sent as a response only to find that the body shows an error. However, by calling the HTTP error function, the body and the status code are set at the same time. Using this approach, all the appropriate headers are set on your behalf, simplifying your solution. But instead of simply sending back a string as error body, we can also create the custom error object containing a lot more detail. In this example, we populate our custom error object using the context of the error, but since the error will be encoded in a JSON format in the response body, we would need to set two things to make the error response clear. The first is the error status header as we've seen previously. The second is the Content‑Type signifying that the body content is JSON. This approach can provide callers with detailed and structured errors making it easier to consume.

Other Errors and Outbound Calls
Let's look at other approaches to error handling and hosting the HTTP server. Let's look at Go's built‑in error wrapping capability. Error wrapping is provided by the func errFunc specifying the %w placeholder and passing in the original error. In our example, we first create a database error as a simple string error. We then wrap the error in an api error and return it as a response from the function. When you receive the error object from the function, you can simply use the error directly giving you access to the error, as well as the wrapped error as a single object. If you want access to the wrapped error, you can call the errors.Unwrap function returning you the wrapped error. This approach to error handling is extremely handy for managing errors through the entire application stack from databases to APIs. You can, of course, take this approach even further with your own custom errors. And finally, when hosting an HTTP or HTTPS server, the servers will only respond with an error if something prevents the server from starting, for example, the portal being available. Once the server starts, all further errors would typically be encountered as part of the requests. Let's now look at outbound HTTP calls. When making outbound HTTP calls, the call will return two values, the response and an error. In our example, the call failed due to the remote endpoint not being available. Instead of catching the error later, our code can immediately respond to the error appropriately. If there's not an error, we can assume the call passed and our code can proceed. By reading the content of the body, you receive a slice of bytes and an error as a response. If this call fails, we will, again, be presented with an appropriate error enabling our solution to respond appropriately. If there is no error, we can assume that we can read and process the information provided in the body.

Summary
In this module, we look at scenarios we may encounter when handling inbound HTTP requests, how to send back errors that is clear and easy to consume, and finally, the errors you may encounter when making outbound HTTP requests. Next, we will look at how we can handle errors related to channels. See you there.

Responding to Channel Errors
Overview
Hi. Let's learn about errors we may experience when working with Go routines and sending data on channels, and of course, how to catch them. I'm Corneile Britz, founder of Boxfish Global. In this module, we will understand what may cause an error to occur when sending messages on channels and how we can catch these errors by using non‑blocking channel operations. Let's get started.

Channel Send Errors
Let's first look at a typical example you may encounter when sending data on a buffered or unbuffered channel. The purpose of the transmit function is to send a value on a provided channel a given amount of times. Each time the value is successfully sent to the channel, it will print the success message as an output. If the function successfully sends all the values, it'll print the output of Done. In the main function, we define a buffer channel with the capacity of 2. This channel is then sent to the transmit function, but specifying that it should send the message 5 times. Please note that we have not specified a reader on the channel emulating a scenario where a reader may perform slower than expected or perhaps died. In the output, you'll know that the first two messages are sent onto the channel correctly, after which it crashes. This is because the channel send is a blocking operation, and without the reader attached, the channel reaches its defined capacity resulting in a deadlock. Let's look at how we can change the transmit function to behave in a less‑risky manner while still keeping the logic of looping a certain amount of times where leverage goes both in select statement to safeguard our channel send operation. If the channel send is successful, it will continue as normal and print the success message. However, if it fails to send a message due to a deadlock as we have previously seen, it will invoke the default case. This will inform us that the send failed and the failed message will be printed. In the output, you will note the first two messages being sent, after which the next three messages fail, finally, reaching the done message. Typically, you would return an error when you realize that the send requests are failing.

Summary
In this module, we reviewed how an error can occur if a channel is blocked, and we looked at using non‑blocking channel operations to catch these errors. Working with goroutines and channels in Go may seem daunting, but this approach provides you with the tools to safeguard your channel interactions. However, we know that even if we handle all the errors on our side and safely send the data over the channel for another goroutine to consume, things can still go wrong. In the next module, we will look at two ways of receiving and handling error responses from Go routines. See you there.

Handling Error Responses in Goroutines
Overview
Hi. Handling errors from goroutines does present an interesting challenge. Let's look at how we can handle them using Go's built‑in functionality. I'm Corneile Britz, founder of Boxfish Global. In this module, we will look at receiving errors from goroutines through the use of separate channels. We will then look at receiving the same errors through a single channel. And finally, we will look at the handling errors from multiple Go routines through the use of error propagation. Please note for this module, we will show each example in two parts. The first part will focus on the implementation of the mechanism. The second part will focus on invoking it and associated output. Let's get started.

Error Channels
Let's first look at handling goroutine errors through the use of channels. In this example, our function returns two channels, one to return the result data and the other to return the error. Please note that both channels are created with the capacity of 1. This is important when returning channels as a result as they may only be read later by the caller. The goroutine is created, and as it tries to read the file, it will return the result data as bytes and an error. If an error is received, it is sent to the errChannel, else it will send the result data to the dataChan. Once done, the goroutine will close both channels indicating that it is complete. The caller receives the data and the error channels as output from the function we just reviewed. First, the function will try to receive the value from the errChan, also checking that the channel was open when it received a notification. If the open check fails, we would know that the event resulted from the channel closing. Else, we can safely interact and print the error if the channel was open and received an error. Next, the function will perform the same check on the dataChan, again, checking for the open channel indicator. We could safely interact and print the result if the channel was open and receive the result. You may think it is wasteful to create separate channels, and even though there are cases where this is necessary, let's look at another approach. For this approach, we create the Result object to contain the data and error as fields of the struct. Instead of returning separate channels, we will return an instance of the result from the function. We create the single channel to send and receive the result in the function and the Result object is received from the channel directly and returned as a function result. Inside the goroutine, the result is instantiated with the data and the error and sent on the resultChan. The main advantage of this approach is the complexity of dealing with channels is contained within the function and only the result is returned, and when the function is called and receives the Result object, you can first test the error field in the Result object. If it is valid, you can safely interact with the error, and if there is no error, you can safely interact with the data. This provides you with multiple approaches to receive results through channels, especially simple for a single goroutine.

Error Propagation
Since we typically employ multiple goroutines to perform large tasks, let's look at handling errors when they occur through the use of propagation. Let's now focus on coordinating multiple goroutines through the use of wait groups, and in our example, the objective is to read the content of multiple files. The main objective of a wait group in this function is to ensure that all the goroutines are completed before exiting the function. This is done by first, creating the WaitGroup at the start of the function, increasing the counter for the wait group by adding values to it. In our example, it is done inside the for loop by calling Add. And finally, decrease the counter by calling Done, which is done inside the goroutine as a defer statement. Let's see what the result looks like. Our calling function first creates a slice of file names which is then sent to our waitGroup function, but only three of the files exist. And since all of the goroutines in our function operate independently, the output shows the error, as well as the file contents that were able to be read. Even though the wait group approach is ideal to ensure that all the goroutines are completed before returning, the danger of handling errors this way becomes abundantly clear. Let's now look at how we can handle these errors. This time, we'll look at the exact same function to read the files, but replacing the wait group with Go's _____ errGroup function. First, we create the errGroup variable, but instead of increasing and decreasing a counter, we call our goroutine using the error group's Go function. It is important to note that the function passed to the errGroup returns an error. Inside the goroutine, the function can simply return the error when it is found as the errGroup will handle this. The value of errGroup becomes evident at the end of the function when the errGroup waits for all the goroutines to complete and returns any errors that were found by the goroutines called. At this stage, we can validate and handle the error, and when we call the function again with the same list of files, it is important to note the order of the output. All the files which could be read are printed first. This is a result of the error for the missing file being sent to the errGroup and not printed, and the error was only received when the errGroup Wait function returned a result. This approach is already better for managing errors between multiple goroutines, but what happens if we don't want the other goroutines to continue if one fails? Let's now look at using errGroup in conjunction with context. This is done by accepting a ctx object in addition to the files and creating an errgroup instance with a new ctx object to be used with the goroutines. The goroutines are still called by using the errGroup's Go function and returning the error, but this is where the similarity to the previous example ends as this time we will use a select statement to perform the following. Check the errGroup's context to see if it is done. As is typical with ctx objects being completed, you cannot as such check the context error and return it as an additional error. The alternative to the ctx being done is to print the successful file contents. It is important to understand the behavior of errgroupcontext. If one of the goroutines fail and return an error, the context will be immediately canceled across the board. This means that all the goroutines will be stopped. Let's look at the output when we call this function. We'll, again, try to read the four files similar to the previous examples. But before we call the function, we create a background context object, but for clarity, we ignore the cancel function as a second return variable. And when we call the function, the output shows how the errGroup with context behave. One file message is read before the file that could not be found resulted in an error. And when the errGroup received this error response, it immediately canceled all the other goroutines, and upon completion, printed the error it received. This approach provides you with an end‑to‑end coordination of goroutines handling errors and ensuring consistent results.

Summary
In this module, we looked at receiving errors on separate channels from goroutines. We then looked at receiving the same errors on a single channel. Finally, we leveraged error propagation to manage multiple goroutines in case something went wrong. This brings us to the end of the error scenarios covered in this course. In the next module, we will review what we have learned. See you there.

Closure
Review and Closure
Hi. You have reached the end of the course on Managing Errors in Go. Let's review what we have covered. I'm Corneile Britz, founder of Boxfish Global. During the course, we covered six main areas that focused on using, leveraging, and extending the Go error functionality and scenarios you may encounter when writing solutions in Go. These consisted of how error objects are defined in Go, including some typical examples you encounter in the standard library, putting in safety mechanisms in your code to catch unexpected errors using defer, panic, and recover, creating tests that include error validation and leveraging table‑driven tests to validate multiple error responses, and constructing your custom errors to fulfill Go's error interface and be able to detect them. Our scenarios included handling inbound and outbound HTTP errors and providing easy‑to‑use responses to consumers of your APIs and dealing with errors when sending and how to receive errors from channels and other goroutines. Thank you for joining me in learning how to manage errors in Go and exploring some common scenarios you encounter. Congratulations on completing the course.